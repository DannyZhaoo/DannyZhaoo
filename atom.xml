<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流光</title>
  <subtitle>细数似水年华的美好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http:/dannyzhaoo.github.io/"/>
  <updated>2017-12-12T06:16:23.527Z</updated>
  <id>http:/dannyzhaoo.github.io/</id>
  
  <author>
    <name>DannyZhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS布局总结</title>
    <link href="http:/dannyzhaoo.github.io/2017/12/12/CSS%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/"/>
    <id>http:/dannyzhaoo.github.io/2017/12/12/CSS布局总结/</id>
    <published>2017-12-12T05:50:40.000Z</published>
    <updated>2017-12-12T06:16:23.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex居中显示"><a href="#flex居中显示" class="headerlink" title="flex居中显示"></a>flex居中显示</h2><p>想要的效果，div内的三个内容分别每一列都是<strong>独占一行并且居中显示</strong>。</p>
<p>HTML结构如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"know"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"270px"</span> <span class="attr">height</span>=<span class="string">"307px"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"know-tip"</span>&gt;</span>报名成功<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">   	<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"know-button"</span>&gt;</span>知道了<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.know</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    @include flexbox;</div><div class="line">    @<span class="keyword">include</span> justify-content;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>问题:</p>
<p>div包含的元素都在一列显示，不是单独占一行，并且这个跟子元素是行内元素还是块级元素无关。</p>
<p>之后把后面两个子元素设置成如下，然后局部再调整。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.know</span> &#123;</div><div class="line">    &amp;-tip, &amp;-<span class="selector-tag">button</span> &#123;</div><div class="line">      	<span class="attribute">position</span>: absolute;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这个在某些手机上，后面两个的位置会被挤的偏右，不是居中显示。所以只能设置单个元素如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.know</span> &#123;</div><div class="line">    &amp;-tip, &amp;-<span class="selector-tag">button</span> &#123;</div><div class="line">      	<span class="attribute">position</span>: absolute;</div><div class="line">      	<span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">      	<span class="attribute">transform</span>: translateX(-<span class="number">50%</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flex居中显示&quot;&gt;&lt;a href=&quot;#flex居中显示&quot; class=&quot;headerlink&quot; title=&quot;flex居中显示&quot;&gt;&lt;/a&gt;flex居中显示&lt;/h2&gt;&lt;p&gt;想要的效果，div内的三个内容分别每一列都是&lt;strong&gt;独占一行并且居中显示&lt;/stro
    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="CSS" scheme="http:/dannyzhaoo.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>更改手机号自动完成输入框的校验</title>
    <link href="http:/dannyzhaoo.github.io/2017/11/10/%E6%9B%B4%E6%94%B9%E6%89%8B%E6%9C%BA%E5%8F%B7%E8%87%AA%E5%8A%A8%E5%AE%8C%E6%88%90%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E6%A0%A1%E9%AA%8C/"/>
    <id>http:/dannyzhaoo.github.io/2017/11/10/更改手机号自动完成输入框的校验/</id>
    <published>2017-11-10T08:21:59.000Z</published>
    <updated>2017-11-10T08:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端技术栈：reactjs + antd + typescript</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>自动完成输入框</strong>在直接复制过来后，出现下拉选项，选择后还是报出“请输入正确的手机号”（需要输入的手机号必须是存在在后端传来的数据库中的）。<br>猜想1：<br>state导致数据的更新延迟。<br>做法1：<br>把自动输入框的source设置从state中变成class的私有变量。<br>结果1：<br>问题还是没有得到解决（此时忽略了这样做，导致出现的新的问题）。<br>猜想2:<br>既然是出现下拉菜单后，没有校验对，那么校验就应该出现在请求全部数据的resolve中。<br>做法2:<br>把antd中的数据校验部分放到resolve中。<br>结果2:<br>这个antd数据校验固定的函数返回的结果不符合要求。</p>
<p>实在想不出原因，第二天就只能重头分析：</p>
<h2 id="明确自己的需求"><a href="#明确自己的需求" class="headerlink" title="明确自己的需求"></a>明确自己的需求</h2><p>更改手机号</p>
<ol>
<li>原手机号必须出现在后端返回的数据库中。</li>
<li>原手机号和新手机号不能一样。</li>
</ol>
<p>此处需要copy后，下拉菜单出现相应的内容，能直接点击，并能出现对号，说明输入的手机号确实在数据库中。</p>
<p>问题3：<br>这个根据输入去搜索匹配的手机号的函数和自动校验输入内容的函数，哪个先发生？<br>做法3：<br>打断点，分析函数过程。<br>结果3：<br>根据输入去搜索匹配的手机号的函数先触发，然后根据输入去校验输入的内容。发现在选择弹出的匹配的手机号后，自动校验函数并没有触发。</p>
<p>问题4：<br>此处如果在选择弹出的匹配的手机号后，触发自动校验的话，那么结果就对了。那么怎么才能触发自动校验函数呢?<br>做法4：<br>根据这个问题去看自己的代码和以前工程实现相同的功能的部分代码写的如何不一样。<br>结果4：<br>然后发现自己对搜索内容返回的结果的封装是不一样的。</p>
<p>做法5:<br>用相同的方法封装搜索返回的结果，只是value和text是一样的。<br>结果5：<br>还是没有起到作用。<br>做法6：<br>把value和text的封装成不一样的。<br>结果6:<br>终于触发了自动校验函数。</p>
<h4 id="结论：只有点击弹出框输入的内容和原来的输入不一样，才能触发自动校验函数。"><a href="#结论：只有点击弹出框输入的内容和原来的输入不一样，才能触发自动校验函数。" class="headerlink" title="结论：只有点击弹出框输入的内容和原来的输入不一样，才能触发自动校验函数。"></a>结论：只有点击弹出框输入的内容和原来的输入不一样，才能触发自动校验函数。</h4><p>问题7：<br>那么把state里的source数据变成private的话，能实现相同的功能吗？<br>结果：<br>试了一下，结果没有弹出框。</p>
<h4 id="结论：1-跟前端界面相关的改变应该放到state中，这样state发生改变的话，界面才能相应的发生响应式改变。2-传入框架插件里的数据只是说明数据，跟界面的渲染没有什么关系，只是保证数据正确。"><a href="#结论：1-跟前端界面相关的改变应该放到state中，这样state发生改变的话，界面才能相应的发生响应式改变。2-传入框架插件里的数据只是说明数据，跟界面的渲染没有什么关系，只是保证数据正确。" class="headerlink" title="结论：1. 跟前端界面相关的改变应该放到state中，这样state发生改变的话，界面才能相应的发生响应式改变。2. 传入框架插件里的数据只是说明数据，跟界面的渲染没有什么关系，只是保证数据正确。"></a>结论：1. 跟前端界面相关的改变应该放到state中，这样state发生改变的话，界面才能相应的发生响应式改变。2. 传入框架插件里的数据只是说明数据，跟界面的渲染没有什么关系，只是保证数据正确。</h4><h4 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h4><p><strong>出现问题后，没有分析问题就直接修改。</strong><br>应该，遇到问题后，心中应该再次确定自己的功能需求，然后查看自己的实现的效果和需求如何的不一样。然后针对现状，先分析哪个和自己的想法中的不一样，然后针对发现的问题再去找答案。</p>
<h4 id="说明在做一件事时，都需要自己先明确自己的目标，然后分析自己的现状，再去做事。"><a href="#说明在做一件事时，都需要自己先明确自己的目标，然后分析自己的现状，再去做事。" class="headerlink" title="说明在做一件事时，都需要自己先明确自己的目标，然后分析自己的现状，再去做事。"></a>说明在做一件事时，都需要自己先明确自己的目标，然后分析自己的现状，再去做事。</h4><h4 id="杜绝无目标和意义的焦急和忙碌。"><a href="#杜绝无目标和意义的焦急和忙碌。" class="headerlink" title="杜绝无目标和意义的焦急和忙碌。"></a>杜绝无目标和意义的焦急和忙碌。</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端技术栈：reactjs + antd + typescript&lt;/p&gt;
&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;自动完成输入框&lt;/strong&gt;在直接复制
    
    </summary>
    
      <category term="技术日记" scheme="http:/dannyzhaoo.github.io/categories/%E6%8A%80%E6%9C%AF%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http:/dannyzhaoo.github.io/2017/10/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/24/前端项目的总结/</id>
    <published>2017-10-24T06:19:44.000Z</published>
    <updated>2017-10-24T07:31:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端项目的总结"><a href="#前端项目的总结" class="headerlink" title="前端项目的总结"></a>前端项目的总结</h2><p>这个项目是基于react+typescript, 所以就选择了ant design 这个前端UI框架。</p>
<p>一般选择了一个框架后，然后基于自己项目中的用法，然后把这些UI组件进行封装。</p>
<p>在选择了一个框架后，要详细看那些接口设置，然后在封装的基础上，添加自己想要的功能模块继承这个封装的类。</p>
<p>学习前端的项目，从最外面的一层开始看代码，然后一层一层往里看。从</p>
<ul>
<li>配置方面开始看，</li>
<li>熟悉目录，</li>
<li>熟悉整个架构。</li>
</ul>
<p>怎么知道引用哪些props和class？</p>
<p>首先要使用table，就肯定需要tableProps，然后根据自己的需要看到在tableProps里面有PaginationProps和ColumnProps，所以就需要添加在新的页面中引用了。</p>
<p>如何用那些props呢？</p>
<p>tableProps  </p>
<ul>
<li>会有函数提供一些table其他的参数。</li>
</ul>
<p>columnProps</p>
<ul>
<li>会有函数提供列的设置，所以返回值需要设置。</li>
</ul>
<p>返回值的类型在TypeScript中有什么影响？如果变量里的内容比定义的更多？</p>
<p>变量比定义的类型内容多，多的变量内容不用管，但是要用的变量内容必须要定义。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前端项目的总结&quot;&gt;&lt;a href=&quot;#前端项目的总结&quot; class=&quot;headerlink&quot; title=&quot;前端项目的总结&quot;&gt;&lt;/a&gt;前端项目的总结&lt;/h2&gt;&lt;p&gt;这个项目是基于react+typescript, 所以就选择了ant design 这个前端UI框架
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用eslint小记</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/17/%E4%BD%BF%E7%94%A8eslint%E5%B0%8F%E8%AE%B0/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/17/使用eslint小记/</id>
    <published>2017-10-17T09:34:53.000Z</published>
    <updated>2017-10-17T09:53:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在工作中，每个队伍都有一套编程规则，方便大家看懂彼此的代码。但是，我看代码就有容易把自己的代码规则和别人的搞混，有时候也会记错。</p>
<p>而今天， 我发现了<strong>Eslint</strong>。这个在写代码的时候真的很方便，会给出提示，但是前提是自己得会配置。所以，把自己踩得的都记一下。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ol>
<li>下载eslint</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g eslint</div><div class="line">eslint --init</div></pre></td></tr></table></figure>
<ol>
<li>写eslint的配置文件。</li>
</ol>
<p>推荐一个github，这个上面列出的eslint配置对<strong>前端</strong>是个很好的参考。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@github.com:AlloyTeam/eslint-config-alloy.git</div></pre></td></tr></table></figure>
<ol>
<li>在vs code上的配置</li>
</ol>
<p>最重要的地方，指明eslint配置的地方。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    "eslint.options": &#123;</div><div class="line">        "eslintConfig": "/Users/workspace/panama-2-m-fe/.eslintrc.json"</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ol>
<li>VS code上提示哪个配置是invalid，那就把那部分给删掉，这就可能是你的eslint版本太低了，不支持这个。（我就一直踩这个坑，还不知道原因）</li>
<li>VS code在开始的时候提示<em>Definition for rule ‘switch-colon-spacing’ was not found</em> 这个是你的eslint版本不支持这个。</li>
<li>不要配置autoFixOnSave，这样最起码代码还在自己控制中，否则一旦规则写错了，你就倒霉了。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在工作中，每个队伍都有一套编程规则，方便大家看懂彼此的代码。但是，我看代码就有容易把自己的代码规则和别人的搞混，有时候也会记错。&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="Eslint" scheme="http:/dannyzhaoo.github.io/categories/Eslint/"/>
    
    
      <category term="开发流程/部署" scheme="http:/dannyzhaoo.github.io/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B-%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>避免使用全局变量</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/12/%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/12/避免使用全局变量/</id>
    <published>2017-10-12T02:03:21.000Z</published>
    <updated>2017-10-12T02:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全局变量带来的问题"><a href="#全局变量带来的问题" class="headerlink" title="全局变量带来的问题"></a>全局变量带来的问题</h1><h2 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h2><p>很可能无意中就是用来一个已经声明的变量。</p>
<blockquote>
<p>所有的变量都使用局部变量。</p>
</blockquote>
<h2 id="代码的脆弱性"><a href="#代码的脆弱性" class="headerlink" title="代码的脆弱性"></a>代码的脆弱性</h2><p>函数依赖于全局变量造成函数的不稳定性提高。</p>
<blockquote>
<p>将数据放在局部作用域内。</p>
</blockquote>
<h2 id="难以测试"><a href="#难以测试" class="headerlink" title="难以测试"></a>难以测试</h2><p>必须创建完整的全局变量才能进行测试。</p>
<h2 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h2><blockquote>
<p>使用JSLint和JSHint。<br>启动严格模式。</p>
</blockquote>
<h1 id="单全局变量方式"><a href="#单全局变量方式" class="headerlink" title="单全局变量方式"></a>单全局变量方式</h1><p>全局只创建一个全局变量，所有功能都挂在到这个全局对象上。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>即是全局变量的功能性分组。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>通用的功能片段，所有的这些代码都存放于一个表示执行一个任务或发布一个接口的单函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;全局变量带来的问题&quot;&gt;&lt;a href=&quot;#全局变量带来的问题&quot; class=&quot;headerlink&quot; title=&quot;全局变量带来的问题&quot;&gt;&lt;/a&gt;全局变量带来的问题&lt;/h1&gt;&lt;h2 id=&quot;命名冲突&quot;&gt;&lt;a href=&quot;#命名冲突&quot; class=&quot;headerli
    
    </summary>
    
      <category term="编程知识储备" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    
    
      <category term="JavaScript编程模式" scheme="http:/dannyzhaoo.github.io/tags/JavaScript%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>UI层的松耦合</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/12/UI%E5%B1%82%E7%9A%84%E6%9D%BE%E8%80%A6%E5%90%88/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/12/UI层的松耦合/</id>
    <published>2017-10-12T01:51:04.000Z</published>
    <updated>2017-10-12T02:07:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>目的：修改一个组件而不需要更改其他组件。</p>
<p>减少跟踪文本和结构性问题的复杂度，提高代码的可维护性。</p>
<ul>
<li>将JavaScript从CSS中抽离</li>
</ul>
<blockquote>
<p>避免在CSS中使用JavaScript代码。</p>
</blockquote>
<ul>
<li>将CSS从JavaScript中抽离。</li>
</ul>
<blockquote>
<p>操作CSS的className来替代直接修改与元素样式。</p>
</blockquote>
<ul>
<li>将JavaScript从HTML中抽离。</li>
</ul>
<blockquote>
<p>使用JavaScript来添加事件，而不是用在HTML中直接给on属性挂载事件。</p>
<p>将所有的JavaScript代码都放入外置文件中。</p>
</blockquote>
<ul>
<li>将HTML从JavaScript中抽离。</li>
</ul>
<blockquote>
<p>定义模板，用占位符或是在HTML中使用变量。类似于vue的data。</p>
</blockquote>
<p><em>摘自《编写可维护的JavaScript》</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目的：修改一个组件而不需要更改其他组件。&lt;/p&gt;
&lt;p&gt;减少跟踪文本和结构性问题的复杂度，提高代码的可维护性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将JavaScript从CSS中抽离&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;避免在CSS中使用JavaScript代码。
    
    </summary>
    
      <category term="编程知识储备" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87/"/>
    
    
      <category term="JavaScript编程模式" scheme="http:/dannyzhaoo.github.io/tags/JavaScript%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>javaScript编码</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/11/javaScript%E7%BC%96%E7%A0%81/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/11/javaScript编码/</id>
    <published>2017-10-11T09:10:21.000Z</published>
    <updated>2017-10-11T09:40:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>javascript 的编码一般有三个，但是常用的是后面两种。</p>
<ol>
<li>escape()、unescape()</li>
</ol>
<p>这个是对字符串的编码，会返回一个字符的Unicode编码值。</p>
<p>escape()这个函数不对“+”编码，因为在提交表单的时候，空格会被转化为+字符。</p>
<p>这个函数现在已经不提倡使用。</p>
<ol>
<li>encodeURl()、decodeURl()</li>
</ol>
<p>对URL其中的某些字符将被十六进制的转义序列进行替换，不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码：;/?:@&amp;=+$,’#。</p>
<ol>
<li>encodeURlComponent()、decodeURlComponent()</li>
</ol>
<p>对URL其中的某些字符将被十六进制的转义序列进行替换，同时也能编码：;/?:@&amp;=+$,’#这些特殊字符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;javascript 的编码一般有三个，但是常用的是后面两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;escape()、unescape()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个是对字符串的编码，会返回一个字符的Unicode编码值。&lt;/p&gt;
&lt;p&gt;escape()这个函数不对“+”编码，
    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http:/dannyzhaoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Date对象的处理技巧</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/11/Date%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/11/Date对象的处理技巧/</id>
    <published>2017-10-11T06:14:44.000Z</published>
    <updated>2017-10-11T09:25:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>获取当前所属的季度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSeason</span> (<span class="params">month</span>) </span>&#123;</div><div class="line">  	<span class="comment">//Math.ceil是向上取整</span></div><div class="line">  	<span class="keyword">return</span> <span class="built_in">Math</span>.ceil((month + <span class="number">1</span>) / <span class="number">3</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>判断一个数据是否为日期对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.toString.call(dateObj) !== <span class="string">'[object Date]'</span></div></pre></td></tr></table></figure>
<ul>
<li>获取某年二月份的最后一天</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">0</span>);</div><div class="line"><span class="comment">// 方法二 60 * 60 * 24 * 1000</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">1</span>) - <span class="number">86400000</span>;</div><div class="line"><span class="comment">// 方法三</span></div><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">1</span>);</div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(date.setDate(date.getDate() - <span class="number">1</span>));</div></pre></td></tr></table></figure>
<ul>
<li>获取当天时间的起始时间</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line"><span class="comment">// 方法一 getMonth()得到的月份比正常少一</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(now.getFullYear() + <span class="string">'-'</span> + (now.getMonth() + <span class="number">1</span>) + <span class="string">'-'</span> + now.getDate() + <span class="string">':00:00:00'</span>);</div><div class="line"><span class="comment">// 方法二</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(now.getFullYear(), now.getMonth(), now.getDate());</div><div class="line"><span class="comment">// 方法3</span></div><div class="line"><span class="keyword">import</span> date <span class="keyword">from</span> <span class="string">'fecha'</span>;</div><div class="line">fecha.parse(<span class="keyword">new</span> <span class="built_in">Date</span>().toString(), <span class="string">'yyyy-MM-dd'</span>);</div></pre></td></tr></table></figure>
<p><em>注意：学习JavaScript的处理函数可以看fecha的源码。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;获取当前所属的季度&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;l
    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http:/dannyzhaoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>阅读vue代码</title>
    <link href="http:/dannyzhaoo.github.io/2017/10/10/%E9%98%85%E8%AF%BBvue%E4%BB%A3%E7%A0%81/"/>
    <id>http:/dannyzhaoo.github.io/2017/10/10/阅读vue代码/</id>
    <published>2017-10-10T08:02:02.000Z</published>
    <updated>2017-10-10T12:42:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>从今天开始我的目标就是读懂我们的公司项目的代码，在这里记录一下自己的阅读代码总结。</p>
<ol>
<li>首先是，先看一下<strong>线上作品</strong>，明白各部分的功能需求。（不懂的话，找测试或是产品经理了解）。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从今天开始我的目标就是读懂我们的公司项目的代码，在这里记录一下自己的阅读代码总结。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先是，先看一下&lt;strong&gt;线上作品&lt;/strong&gt;，明白各部分的功能需求。（不懂的话，找测试或是产品经理了解）。&lt;/li&gt;
&lt;/ol&gt;

    
    </summary>
    
      <category term="软技能" scheme="http:/dannyzhaoo.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="vue" scheme="http:/dannyzhaoo.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>git版本回退</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/12/git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/12/git版本回退/</id>
    <published>2017-09-12T07:56:26.000Z</published>
    <updated>2017-09-12T09:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h1><p>回退git的版本提交的commit</p>
<p>参数:</p>
<p>—soft: 只改变本地仓库的提交点，而暂存区和工作区都不改变</p>
<p>—mixed: 改变本地仓库和暂存区，工作区不变</p>
<p>—hard: 本地仓库、暂存区、工作区全部改变</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>回退最新的修改</div><div class="line">git reset --hard HEAD^</div><div class="line">git reset --hard HEAD~3</div><div class="line"><span class="meta">#</span>回退哈希值为3628164...的修改，注意3628164...之后的也被改变</div><div class="line">git reset --hard 3628164</div></pre></td></tr></table></figure>
<h1 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h1><p>回退git的版本，并把这次的回退作为一次修改提交。</p>
<p>用法同reset</p>
<h1 id="远程仓库回退"><a href="#远程仓库回退" class="headerlink" title="远程仓库回退"></a>远程仓库回退</h1><ol>
<li>在本地用resert，然后提交到远程仓库。（推荐）</li>
<li>在本地用reset，然后用<code>git push --force</code>。</li>
<li>在本地用reset，然后用删除远程的master分支<code>git push origin :master</code>，重建master分支<code>git push origin master</code>。</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>如果回退之后，又觉得以前写的是正确的，这次的回退是误操作，那怎么办呢?</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>查看自己的电脑上的操作哈希值</div><div class="line"><span class="meta">$</span> git reflog</div><div class="line"><span class="meta">#</span>再重新调整git的HEAD</div><div class="line"><span class="meta">$</span> git reset --hard a123456</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;reset&quot;&gt;&lt;a href=&quot;#reset&quot; class=&quot;headerlink&quot; title=&quot;reset&quot;&gt;&lt;/a&gt;reset&lt;/h1&gt;&lt;p&gt;回退git的版本提交的commit&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;—soft: 只改变本地仓库的提交点，而暂存
    
    </summary>
    
      <category term="开发工具" scheme="http:/dannyzhaoo.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="git" scheme="http:/dannyzhaoo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浏览器调试</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/11/浏览器调试/</id>
    <published>2017-09-11T10:48:25.000Z</published>
    <updated>2017-09-11T11:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在写CKeditor的插件时，有一个问题一直报错，而只是单纯用<code>console.log</code>已经不管用了。</p>
<p>所以就问了一下，下面记录一下。</p>
<ol>
<li>简单的就是在文本中添加<code>console.log</code>，查看相应的值。一般这种适应于<strong>非引用类型</strong>来检查。</li>
<li>结合浏览器的<code>console</code>，查看报错的地方在哪些地方。在相应的地方（即source下），加上断点，结合右边<strong>watch</strong>、<strong>call</strong> <strong>stack</strong>、<strong>scope</strong>来进行查看。</li>
<li>跟后端的交互时，在network下就很管用。Headers下面的general和response是服务器对后端的返回。属于http协议部分。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在写CKeditor的插件时，有一个问题一直报错，而只是单纯用&lt;code&gt;console.log&lt;/code&gt;已经不管用了。&lt;/p&gt;
&lt;p&gt;所以就问了一下，下面记录一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单的就是在文本中添加&lt;code&gt;console.log&lt;/code&gt;，
    
    </summary>
    
      <category term="Chrome" scheme="http:/dannyzhaoo.github.io/categories/Chrome/"/>
    
    
      <category term="调试工具" scheme="http:/dannyzhaoo.github.io/tags/%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ES6部分知识点</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/06/ES6%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/06/ES6部分知识点/</id>
    <published>2017-09-06T02:50:40.000Z</published>
    <updated>2017-09-06T03:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>rest参数我也是第一次看到，形为<code>...变量名</code>，用于获取函数多余的参数。</p>
<p>就是说，可以用这个获取函数传过来的所有参数，而我们可以通过遍历<code>变量名</code>来进行自己想要进行的操作。</p>
<p>rest参数中的变量其实就是一个数组，所以也可以进行关于数组的任何操作。</p>
<p><strong>注意：</strong>rest参数只能是最后一个参数。不然会报错的。</p>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><p>这个方法是ES6新的语法，是用于将对象合并起来。</p>
<p>参数是对象，可以有很多。但是默认第一个对象是目标对象，后面全都是源对象。</p>
<p>这样做的目的是把源对象里面可枚举的属性都复制到目标对象里面。</p>
<p>这个的返回值，如果参数只有目标对象，则返回目标对象，如果还有别的可用参数，则返回新的合并起来的对象。</p>
<p>这里面这个方法实行的是<strong>浅拷贝</strong>。如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。该注意就要注意到。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;rest参数&quot;&gt;&lt;a href=&quot;#rest参数&quot; class=&quot;headerlink&quot; title=&quot;rest参数&quot;&gt;&lt;/a&gt;rest参数&lt;/h1&gt;&lt;p&gt;rest参数我也是第一次看到，形为&lt;code&gt;...变量名&lt;/code&gt;，用于获取函数多余的参数。&lt;/p&gt;

    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http:/dannyzhaoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout用法</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/06/setTimeout%E7%94%A8%E6%B3%95/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/06/setTimeout用法/</id>
    <published>2017-09-06T02:38:25.000Z</published>
    <updated>2017-09-06T02:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>setTimeout 永远是里面的函数一执行完，就被销毁。</p>
<p>而clearTimeout是在setTimeout里面的函数没被执行的时候就销毁。</p>
<p>setTimeout同时还有别的作用就是这个里面的函数是在所有同步的函数执行完后，才开始执行。相当于改变了代码的执行顺序。</p>
<p>这样做目前的作用是DOM需要绑定这个函数，然而在执行的时候，DOM没有渲染完，函数无法找到DOM，所以需要滞后调用。</p>
<p>而在setTimeout里面写推迟执行的时间，也不是准确的时间。是在所有的函数执行完后才开始计时，这样的计时当然不准。只能做大概推测。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;setTimeout 永远是里面的函数一执行完，就被销毁。&lt;/p&gt;
&lt;p&gt;而clearTimeout是在setTimeout里面的函数没被执行的时候就销毁。&lt;/p&gt;
&lt;p&gt;setTimeout同时还有别的作用就是这个里面的函数是在所有同步的函数执行完后，才开始执行。相当于改
    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="JavaScript" scheme="http:/dannyzhaoo.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>进度审核</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/05/%E8%BF%9B%E5%BA%A6%E5%AE%A1%E6%A0%B8/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/05/进度审核/</id>
    <published>2017-09-05T11:56:07.000Z</published>
    <updated>2017-09-05T12:04:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个周五离开公司之前，产品经理和技术部门一定都会过一下进度。我刚来，不知道为什么做这个，有时候还会觉得很麻烦。但是最近的阅读的书让我渐渐明白这个的作用。</p>
<p>在此写下来，以后再发现再补充。</p>
<ol>
<li>了解最新进展</li>
<li>确定技术点不遗漏</li>
<li>评估风险点</li>
</ol>
<p>产品不是技术，不能对所有的内容都面面俱到，同时也需要大家相互了解一下进度，了解团队情况。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个周五离开公司之前，产品经理和技术部门一定都会过一下进度。我刚来，不知道为什么做这个，有时候还会觉得很麻烦。但是最近的阅读的书让我渐渐明白这个的作用。&lt;/p&gt;
&lt;p&gt;在此写下来，以后再发现再补充。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;了解最新进展&lt;/li&gt;
&lt;li&gt;确定技术点不遗漏
    
    </summary>
    
      <category term="软技能" scheme="http:/dannyzhaoo.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="团队沟通" scheme="http:/dannyzhaoo.github.io/tags/%E5%9B%A2%E9%98%9F%E6%B2%9F%E9%80%9A/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript规范</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/05/JavaScript%E8%A7%84%E8%8C%83/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/05/JavaScript规范/</id>
    <published>2017-09-05T01:21:59.000Z</published>
    <updated>2017-09-05T01:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>进入公司学习，平时最大的问题除了自己需要学习很多东西外，就是各种代码的缩进和空格等问题。所以在此记录一下自己一直出错的问题。</p>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 三元运算符由3部分组成，因此其换行应当根据每个部分的长度不同，形成不同的情况。</span></div><div class="line"><span class="keyword">var</span> result = thisIsAVeryVeryLongCondition</div><div class="line">    ? resultA : resultB;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = condition</div><div class="line">    ? thisIsAVeryVeryLongResult</div><div class="line">    : resultB;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进入公司学习，平时最大的问题除了自己需要学习很多东西外，就是各种代码的缩进和空格等问题。所以在此记录一下自己一直出错的问题。&lt;/p&gt;
&lt;h1 id=&quot;三元运算符&quot;&gt;&lt;a href=&quot;#三元运算符&quot; class=&quot;headerlink&quot; title=&quot;三元运算符&quot;&gt;&lt;/a&gt;三
    
    </summary>
    
      <category term="前端标准/规范" scheme="http:/dannyzhaoo.github.io/categories/%E5%89%8D%E7%AB%AF%E6%A0%87%E5%87%86-%E8%A7%84%E8%8C%83/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo利用不同分支在不同的电脑上写作</title>
    <link href="http:/dannyzhaoo.github.io/2017/09/04/hexo%E5%88%A9%E7%94%A8%E4%B8%8D%E5%90%8C%E5%88%86%E6%94%AF%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E4%BD%9C/"/>
    <id>http:/dannyzhaoo.github.io/2017/09/04/hexo利用不同分支在不同的电脑上写作/</id>
    <published>2017-09-04T10:20:19.000Z</published>
    <updated>2017-09-05T11:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>我在面对这个问题的时候，其实考虑过放弃GitHub Page，去转而用更方便的现成的博客平台。然而经过对比，还有结合我这个写博客的特点，其实还是用<strong>markdown</strong>最方便。</p>
<p>还有毕竟自己是个程序员，什么都是自己可控的，这对自己还是有不小的吸引力的。</p>
<p>当时我的情况是：</p>
<p>我一直在windows上写东西，但是最近我到公司发了新的电脑，我在GitHub Page上的是用hexo生成后的代码。这样就算我clone下来，也没有自己原来配置的内容。</p>
<p>这样的情况下，我在网上查到可以用这个仓库的另外一个分支保存源码的方式。我就照着做了，大概用了两三个小时，踩了不少坑。</p>
<ol>
<li><p>在本地新建一个分支。</p>
</li>
<li><p>把这个分支推到GitHub上。<br>当然在这个之前，你得确保把这个文件夹都<code>git init</code>过了，而且添加了<code>git remote</code>。</p>
</li>
<li><p>把这个新建的分支设置成默认分支。</p>
</li>
</ol>
<p>在新的电脑上</p>
<ol>
<li>从clone这个仓库</li>
<li><p>用npm下载hexo-cli，hexo，hexo-deployer-git</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div><div class="line">npm install hexo</div><div class="line">npm install</div><div class="line">npm install hexo-deployer-git –-save</div></pre></td></tr></table></figure>
</li>
<li><p>切记下载主题git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</li>
<li>按照需要<strong>设置主题</strong>，这个不会在git上有记录。</li>
</ol>
<p>最后切记自己遇到问题，不要一切就真的推翻重做，其实再查查就成功了。或者倒退几步，但是真的不用全部重新来过。</p>
<p>这个步骤是我后来总结的，我自己做的时候一直有问题，然后就一直查。而且每个电脑环境不同，遇到的问题也不同，一定不要全部推翻重做！！！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在面对这个问题的时候，其实考虑过放弃GitHub Page，去转而用更方便的现成的博客平台。然而经过对比，还有结合我这个写博客的特点，其实还是用&lt;strong&gt;markdown&lt;/strong&gt;最方便。&lt;/p&gt;
&lt;p&gt;还有毕竟自己是个程序员，什么都是自己可控的，这对自己还
    
    </summary>
    
      <category term="开发工具" scheme="http:/dannyzhaoo.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http:/dannyzhaoo.github.io/tags/hexo/"/>
    
      <category term="git" scheme="http:/dannyzhaoo.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>ps技能---切图</title>
    <link href="http:/dannyzhaoo.github.io/2017/06/11/ps%E6%8A%80%E8%83%BD-%E5%88%87%E5%9B%BE/"/>
    <id>http:/dannyzhaoo.github.io/2017/06/11/ps技能-切图/</id>
    <published>2017-06-11T02:37:48.000Z</published>
    <updated>2017-09-05T11:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li>从psd中 <strong>获取</strong>网页前端开发过程中所需要的资源。</li>
<li>简单photoshop操作。</li>
<li>简单图片的处理和调整。</li>
<li>提高审美和美感。</li>
</ol>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h2 id="传统切图"><a href="#传统切图" class="headerlink" title="传统切图"></a>传统切图</h2><h2 id="精准切图"><a href="#精准切图" class="headerlink" title="精准切图"></a>精准切图</h2><h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从psd中 &lt;strong&gt;获取&lt;/strong&gt;网页前端开发过程中所需要的资源。&lt;/li&gt;
&lt;li&gt;简单photoshop操作
    
    </summary>
    
      <category term="切页面" scheme="http:/dannyzhaoo.github.io/categories/%E5%88%87%E9%A1%B5%E9%9D%A2/"/>
    
    
      <category term="Photoshop" scheme="http:/dannyzhaoo.github.io/tags/Photoshop/"/>
    
  </entry>
  
  <entry>
    <title>安装Gitbook</title>
    <link href="http:/dannyzhaoo.github.io/2017/06/08/%E5%AE%89%E8%A3%85Gitbook/"/>
    <id>http:/dannyzhaoo.github.io/2017/06/08/安装Gitbook/</id>
    <published>2017-06-08T13:25:35.000Z</published>
    <updated>2017-09-05T11:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gitbook安装"><a href="#Gitbook安装" class="headerlink" title="Gitbook安装"></a>Gitbook安装</h2><p>安装gitbook的前提是已经安装过nodejs</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//安装gitbook</div><div class="line">D:&gt; npm install gitbook-cli -g</div><div class="line">//验证</div><div class="line">D:&gt;	gitbook -v</div></pre></td></tr></table></figure>
<h2 id="图书编辑"><a href="#图书编辑" class="headerlink" title="图书编辑"></a>图书编辑</h2><h3 id="先建立SUMMARY-md"><a href="#先建立SUMMARY-md" class="headerlink" title="先建立SUMMARY.md"></a>先建立SUMMARY.md</h3><p>这个文件是一本书的目录结构，使用markdown语法，这个文件在使用gitbook命令行之前要先写好，以便之后生成书的目录。例如：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">* </span>[<span class="string">基本安装</span>](<span class="link">howtouse/README.md</span>)</div><div class="line"> - [<span class="string">Node.js安装</span>](<span class="link">howtouse/Nodejsinstall.md</span>)</div><div class="line"> - [<span class="string">Gitbook安装</span>](<span class="link">howtouse/gitbookinstall.md</span>)</div><div class="line"> - [<span class="string">Gitbook命令行速览</span>](<span class="link">howtouse/gitbookcli.md</span>)</div><div class="line"><span class="bullet">* </span>[<span class="string">图书编辑</span>](<span class="link">book/README.md</span>)</div><div class="line"> - [<span class="string">gitbook命令行&amp;markdown编辑</span>](<span class="link">book/gitbook-cli.md</span>)</div><div class="line"> - [<span class="string">gitbook editor编辑</span>](<span class="link">book/editor.md</span>)</div><div class="line"><span class="bullet">* </span>[<span class="string">图书输出</span>](<span class="link">output/README.md</span>)</div><div class="line"> - [<span class="string">输出为静态网站</span>](<span class="link">output/outfile.md</span>)</div><div class="line"> - [<span class="string">输出PDF</span>](<span class="link">output/pdfandebook.md</span>)</div><div class="line"><span class="bullet">* </span>[<span class="string">发布</span>](<span class="link">publish/README.md</span>)</div><div class="line">  - [<span class="string">发布到gitbook.com</span>](<span class="link">publish/gitbook.md</span>)</div><div class="line">  - [<span class="string">Github集成</span>](<span class="link">publish/github.md</span>)</div><div class="line">  - [<span class="string">发布到Github Pages</span>](<span class="link">publish/gitpages.md</span>)</div><div class="line"><span class="bullet">* </span>[<span class="string">结束</span>](<span class="link">end/README.md</span>)</div></pre></td></tr></table></figure>
<p>列表加链接，链接中可以使用目录，也可以不必使用。</p>
<h2 id="书籍目录初始化-amp-内容编写"><a href="#书籍目录初始化-amp-内容编写" class="headerlink" title="书籍目录初始化&amp;内容编写"></a>书籍目录初始化&amp;内容编写</h2><p>在存书籍的目录下，先建立了<code>SUMMARY.md</code>，然后用<code>gitbook init</code>，就会生成一系列目录文件。</p>
<h2 id="图书输出"><a href="#图书输出" class="headerlink" title="图书输出"></a>图书输出</h2><h3 id="输出为静态网站"><a href="#输出为静态网站" class="headerlink" title="输出为静态网站"></a>输出为静态网站</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//在目录文件下</div><div class="line">gitbook serve .</div><div class="line">gitbook serve ./</div></pre></td></tr></table></figure>
<p>之后就可以在自己浏览器输入<code>http://localhost:4000</code>来查看。</p>
<p>这里你会发现，你在你的图书项目的目录中多了一个名为<code>_book</code>的文件目录，而这个目录中的文件，即是生成的静态网站内容。</p>
<h4 id="使用build参数生成到指定目录"><a href="#使用build参数生成到指定目录" class="headerlink" title="使用build参数生成到指定目录"></a>使用build参数生成到指定目录</h4><ol>
<li>mkdir outbook</li>
<li>cd..,退到上一层目录，即E:\gitbook (如果不，会出错)</li>
<li>然后,E:\gitbook&gt;gitbook build gitbook-studying gitbook-studying/outbook</li>
<li>则在 E:\gitbook\gitbook-studying\outbook下生成了同样的静态html文件</li>
</ol>
<h3 id="输出pdf"><a href="#输出pdf" class="headerlink" title="输出pdf"></a>输出pdf</h3><p>输出pdf文件步骤如下:</p>
<ol>
<li>由于生成PDF文件依赖于<code>ebook-convert</code>，故首先在该处<a href="http://calibre-ebook.com/download" target="_blank" rel="external">ebook-convert下载链接</a>点击下载所需要的版本，安装即可;</li>
<li>打开cmd，进入E:\gitbook目录;</li>
<li>E:\gitbook&gt;gitbook pdf gitbook-studying gitbook-studying/gitbook入门教程.pdf</li>
<li>则在目录E:\gitbook\gitbook-studying下生成了该pdf文件</li>
</ol>
<p>然后，你会发现你的目录里多了一个名为<code>gitbook入门教程.pdf</code>的文件，就是它了！</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="发布到gitbook-com"><a href="#发布到gitbook-com" class="headerlink" title="发布到gitbook.com"></a>发布到gitbook.com</h3><p>先在线创建一个书的仓库，然后用git来管理。</p>
<ol>
<li>首先打开cmd，进入书籍目录，E:\gitbook\gitbook-studying;</li>
<li>运行E:\gitbook\gitbook-studying&gt;<code>git init</code>，这里如果git提示错误，则是没配置git的环境变量的path；</li>
<li>将目录的章节文件夹一个个加进，git里，使用<code>git add 文件夹名</code>;</li>
<li>接下来，<code>git commit -m &quot;提交信息(必填，否则出错)&quot;</code>;</li>
<li>然后，将本地的git 仓库与gitbook.com上远程仓库连接，<code>git remote add gitbook https://git.gitbook.com/yuzeshan/gitbook-studying.git</code>(注意:不是github上的git remote add origin git@….);</li>
<li>最后，将本地仓库全部push到远程，<code>git push -u gitbook master</code>，以后每次更改，然后add再commit，而第二次push时，直接<code>git push gitbook master</code>即可</li>
</ol>
<p>提交到 GitBook.com 后，书籍就自动发布了，用户就可以通过书籍的地址访问了，例如：<a href="http://yuzeshan.gitbooks.io/gitbook-studying/content/" target="_blank" rel="external">http://yuzeshan.gitbooks.io/gitbook-studying/content/</a></p>
<p><strong>ps:如果本地没有git初始化过得仓库，则可以将在线建立的仓库，克隆到本地，进行修改，提交，push，简洁步骤如下:</strong></p>
<ol>
<li>首先进入想要建立书籍的目录，这里是E:\gitbook\gitbook-studying；</li>
<li>运行命令<code>git clone https://git.gitbook.com/yuzeshan/gitbook-studying.git</code>;</li>
<li>然后，通过之前介绍的书籍编辑:gitbook init,gitbook serve 等方法，编辑好书籍后，再用git命令add commit添加提交书籍目录文件；</li>
<li>最后，<code>git push gitbook master</code>即可。</li>
</ol>
<h3 id="发布到github仓库"><a href="#发布到github仓库" class="headerlink" title="发布到github仓库"></a>发布到github仓库</h3><ol>
<li>首先在github上建立相应的仓库。</li>
<li>创建一个新的文件，在里面运行命令 <code>$git clone git@github.com:yuzeshan/gitbook-studying.git</code>。</li>
<li>进入到这个<code>gitbook-studying</code>文件里。</li>
<li>到Gitbook.com页面，将书籍的 Git 项目设置为 GitHub 上的项目。</li>
<li>保存后，可以看到之前不可点击的 “Add a deployment webhook” 按钮已经可以点击了，这个按钮表示：每当用户配置的 GitHub 上的项目更新时，自动更新Gitbook.com书籍</li>
<li>将之前编辑的书籍目录为<code>E:\gitbook\gitbook-studying</code>中除.git文件，全部拷贝到克隆的目录中，即<code>E:\gitbook\gitbook-studying-github\gitbook-studying</code>中；</li>
<li>将已经编辑好的书籍文件，用git add/commit命令依次添加，提交后;</li>
<li>接下来将书籍仓库与远程github连接到一起，运行命令:<code>git remote add github https://github.com//yuzeshan/gitbook-studying.git</code>(注意:并不是<code>git remote add origin https://github.com:yuzeshan/gitbook-studying.git</code>,也许不运行此命令也可，因为克隆的文件本身就关联了，未尝试。。。)；</li>
<li>最后，将书籍仓库push到github仓库上，运行命令：<code>git push -u github master</code>;</li>
<li>git push 命令中的 -u 表示将本地 master 分支的上游分支设置为 github/master，所以以后修改了本地 master 分支后，git push 将推送到 github 上，而非原来的 <code>git remote add gitbook https://git.gitbook.com/yuzeshan/gitbook-studying.git</code>。</li>
</ol>
<h3 id="发布到GitHub-Pages"><a href="#发布到GitHub-Pages" class="headerlink" title="发布到GitHub Pages"></a>发布到GitHub Pages</h3><p>在自己的代码仓库里添加一个GitHub  Pages静态文件。</p>
<ol>
<li>创建一个空仓库</li>
<li>克隆到本地</li>
<li>创建一个新分支<code>git checkout -b gh-pages</code>，注意，分支必须为 <strong>gh-pages</strong>。</li>
<li>将分支push到仓库 <code>git push -u origin gh-pages</code>。</li>
<li>切换到主分支 <code>git checkout master</code>。</li>
<li>克隆 <code>gh-pages</code>分支 <code>git clone -b gh-pages git@github.com:USERNAME/book.git book-end</code>。这步克隆 <code>gh-pages</code>分支并存放在 <code>book-end</code>目录中。</li>
<li>而且只能copy，用build会把git信息去掉。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gitbook安装&quot;&gt;&lt;a href=&quot;#Gitbook安装&quot; class=&quot;headerlink&quot; title=&quot;Gitbook安装&quot;&gt;&lt;/a&gt;Gitbook安装&lt;/h2&gt;&lt;p&gt;安装gitbook的前提是已经安装过nodejs&lt;/p&gt;
&lt;figure class
    
    </summary>
    
      <category term="开发工具" scheme="http:/dannyzhaoo.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="gitbook" scheme="http:/dannyzhaoo.github.io/tags/gitbook/"/>
    
  </entry>
  
  <entry>
    <title>代码的组织和部署</title>
    <link href="http:/dannyzhaoo.github.io/2017/06/08/%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%84%E7%BB%87%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
    <id>http:/dannyzhaoo.github.io/2017/06/08/代码的组织和部署/</id>
    <published>2017-06-08T01:04:29.000Z</published>
    <updated>2017-09-05T11:37:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式。</p>
<h2 id="模块路径解析规则"><a href="#模块路径解析规则" class="headerlink" title="模块路径解析规则"></a>模块路径解析规则</h2><p><code>require</code>函数支持绝对路径、也支持相对路径。但是这两种路径在模块之间建立了强耦合关系，一点某个模块文件的存放位置需要变更，使用该模块的其他模块的代码也需要跟着调整。因此，<code>require</code>函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块的位置。</p>
<h3 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h3><p>如果传递给<code>require</code>函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如<code>require(&#39;fs&#39;)</code>。</p>
<h3 id="node-modules目录"><a href="#node-modules目录" class="headerlink" title="node_modules目录"></a>node_modules目录</h3><p>NodeJS定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径为<code>/home/user/hello.js</code>，在该模块中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，则NodeJS依次尝试使用以下路径。</p>
<blockquote>
<p>/home/user/node_modules/foo/bar</p>
<p>/home/node_modules/foo/bar</p>
<p>/node_modules/foo/bar</p>
</blockquote>
<h3 id="NODE-PATH环境变量"><a href="#NODE-PATH环境变量" class="headerlink" title="NODE_PATH环境变量"></a>NODE_PATH环境变量</h3><p>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量:</p>
<blockquote>
<p>NODE_PATH=/home/user/lib:/home/lib</p>
</blockquote>
<p>当使用<code>require(&#39;foo/bar&#39;)</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<blockquote>
<p>/home/user/lib/foo/bar</p>
<p>/home/lib/foo/bar</p>
</blockquote>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把有多个子模块组成的大模块称作<strong>包</strong>，并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块。入口模块的导出对象被作为包的导出对象。例如有以下目录结构：</p>
<blockquote>
<p>- /home/user/lib/<br>​    - cat/<br>​        head.js<br>​        body.js<br>​        main.js</p>
</blockquote>
<p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> head = <span class="built_in">require</span>(<span class="string">'./head'</span>);</div><div class="line"><span class="keyword">var</span> body = <span class="built_in">require</span>(<span class="string">'./body'</span>);</div><div class="line"></div><div class="line">exports.create = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name: name,</div><div class="line">        head: head.create(),</div><div class="line">        body: body.create()</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在其他模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require(&#39;/home/user/lib/cat/main&#39;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p>
<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat'</span>)</div><div class="line"><span class="keyword">var</span> cat = <span class="built_in">require</span>(<span class="string">'/home/user/lib/cat/index'</span>)</div></pre></td></tr></table></figure>
<p>这样处理后，就只需要把包目录路径传递给<code>require</code>函数，感觉上整个目录被当作单个模块使用，更有整体感。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中<code>cat</code>模块可以重构如下：</p>
<blockquote>
<p>- /home/user/lib/<br>​    -  cat/<br>​        + doc/<br>​        - lib/<br>​            head.js<br>​            body.js<br>​            main.js<br>​        + tests/<br>​        package.json</p>
</blockquote>
<p>其中<code>package.json</code>内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>: <span class="string">"cat"</span>,</div><div class="line">    <span class="attr">"main"</span>: <span class="string">"./lib/main.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此一来，就可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h2 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h2><p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码的时候需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p>
<p>例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有的功能。并且写好后，我们该把程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> node /home/user/bin/node-echo.js Hello World</div><div class="line">Hello World</div></pre></td></tr></table></figure>
<p>这种使用方式看起来不怎么像是一个命令行程序，下面的才是我们期望的方式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> node-echo Hello World</div></pre></td></tr></table></figure>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：</p>
<ol>
<li><p>在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在<code>node-echo.js</code>文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /usr/bin/env node</span></div></pre></td></tr></table></figure>
<p>NodeJS会忽略掉位于JS模块首行的<code>#!</code>注释，不必担心这行注释是非法语句。</p>
</li>
<li><p>然后，我们使用以下命令赋予<code>node-echo.js</code>文件执行权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> chmod +x /home/user/bin/node-echo.js</div></pre></td></tr></table></figure>
</li>
<li><p>最后，我们在PATH环境变量中指定的某个目录下，例如在<code>/usr/local/bin</code>下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows系统下的做法完全不同，我们得靠<code>.cmd</code>文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\Users\user\bin</code>目录，并且该目录已经添加到<strong>PATH环境变量</strong>里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@node &quot;C:\User\user\bin\node-echo.js&quot; %*</div></pre></td></tr></table></figure>
<p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个<strong>命令行程序</strong>为例，一般我们会同时提供<strong>命令行模式</strong>和<strong>API模式</strong>两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的<strong>文档</strong>和<strong>测试用例</strong>。因此，一个标准的工程目录都看起来像下边这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- /home/user/workspace/node-echo/   # 工程目录</div><div class="line">    - bin/                          # 存放命令行相关代码</div><div class="line">        node-echo</div><div class="line">    + doc/                          # 存放文档</div><div class="line">    - lib/                          # 存放API相关代码</div><div class="line">        echo.js</div><div class="line">    - node_modules/                 # 存放三方包</div><div class="line">        + argv/</div><div class="line">    + tests/                        # 存放测试用例</div><div class="line">    package.json                    # 元数据文件</div><div class="line">    README.md                       # 说明文件</div></pre></td></tr></table></figure>
<p>其中部分文件内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* bin/node-echo */</span></div><div class="line"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'argv'</span>),</div><div class="line">    echo = <span class="built_in">require</span>(<span class="string">'../lib/echo'</span>);</div><div class="line"><span class="built_in">console</span>.log(echo(argv.join(<span class="string">' '</span>)));</div><div class="line"></div><div class="line"><span class="comment">/* lib/echo.js */</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> message;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/* package.json */</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"node-echo"</span>,</div><div class="line">    <span class="string">"main"</span>: <span class="string">"./lib/echo.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p>
<h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。</p>
<h3 id="下载三方包"><a href="#下载三方包" class="headerlink" title="下载三方包"></a>下载三方包</h3><p>需要使用三方包时，首先得知道有哪些包可用。虽然<a href="https://npmjs.org/" target="_blank" rel="external">npmjs.org</a>提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。知道了包名后，比如上边例子中的<code>argv</code>，就可以在工程目录下打开终端，使用以下命令来下载三方包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv</div><div class="line">...</div><div class="line">argv@0.0.2 node_modules\argv</div></pre></td></tr></table></figure>
<p>下载好之后，<code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中，因此在代码中只需要通过<code>require(&#39;argv&#39;)</code>的方式就好，无需指定三方包路径。</p>
<p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@</code>，例如通过以下命令可下载0.0.1版的<code>argv</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install argv@0.0.1</div><div class="line">...</div><div class="line">argv@0.0.1 node_modules\argv</div></pre></td></tr></table></figure>
<p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;node-echo&quot;,</div><div class="line">    &quot;main&quot;: &quot;./lib/echo.js&quot;,</div><div class="line">    &quot;dependencies&quot;: &#123;</div><div class="line">        &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- project/</div><div class="line">    - node_modules/</div><div class="line">        - node-echo/</div><div class="line">            - node_modules/</div><div class="line">                + argv/</div><div class="line">            ...</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p>
<h3 id="安装命令行程序"><a href="#安装命令行程序" class="headerlink" title="安装命令行程序"></a>安装命令行程序</h3><p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install node-echo -g</div></pre></td></tr></table></figure>
<p>参数中的<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的<code>.cmd</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- /usr/local/               # Linux系统下</div><div class="line">    - lib/node_modules/</div><div class="line">        + node-echo/</div><div class="line">        ...</div><div class="line">    - bin/</div><div class="line">        node-echo</div><div class="line">        ...</div><div class="line">    ...</div><div class="line"></div><div class="line">- %APPDATA%\npm\            # Windows系统下</div><div class="line">    - node_modules\</div><div class="line">        + node-echo\</div><div class="line">        ...</div><div class="line">    node-echo.cmd</div><div class="line">    ...</div></pre></td></tr></table></figure>
<h3 id="发布代码"><a href="#发布代码" class="headerlink" title="发布代码"></a>发布代码</h3><p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。接着上边<code>node-echo</code>的例子，<code>package.json</code>里必要的字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;node-echo&quot;,           # 包名，在NPM服务器上须要保持唯一</div><div class="line">    &quot;version&quot;: &quot;1.0.0&quot;,            # 当前版本号</div><div class="line">    &quot;dependencies&quot;: &#123;              # 三方包依赖，需要指定包名和版本号</div><div class="line">        &quot;argv&quot;: &quot;0.0.2&quot;</div><div class="line">      &#125;,</div><div class="line">    &quot;main&quot;: &quot;./lib/echo.js&quot;,       # 入口模块位置</div><div class="line">    &quot;bin&quot; : &#123;</div><div class="line">        &quot;node-echo&quot;: &quot;./bin/node-echo&quot;      # 命令行程序名和主模块位置</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p>
<p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ 如果只是修复bug，需要更新Z位。</div><div class="line"></div><div class="line">+ 如果是新增了功能，但是向下兼容，需要更新Y位。</div><div class="line"></div><div class="line">+ 如果有大变动，向下不兼容，需要更新X位。</div></pre></td></tr></table></figure>
<p>版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如<code>&quot;argv&quot;: &quot;0.0.x&quot;</code>表示依赖于<code>0.0.x</code>系列的最新版<code>argv</code>。NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>除了本章介绍的部分外，NPM还提供了很多功能，<code>package.json</code>里也有很多其它有用的字段。除了可以在<a href="https://npmjs.org/doc/" target="_blank" rel="external">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。</p>
<ul>
<li>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</li>
<li>使用<code>npm help</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</li>
<li>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用<code>npm update</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</li>
<li>使用<code>npm update -g</code>可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用<code>npm unpublish @</code>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点：</p>
<ul>
<li>编写代码前先规划好目录结构，才能做到有条不紊。</li>
<li>稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。</li>
<li>合理使用<code>node_modules</code>和<code>NODE_PATH</code>来解耦包的使用方式和物理路径。</li>
<li>使用NPM加入NodeJS生态圈互通有无。</li>
<li>想到了心仪的包名时请提前在NPM上抢注。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式。&lt;/p&gt;
&lt;h2 id=&quot;模块路径解析规则&quot;&gt;&lt;a href=&quot;#模块路径解析规则&quot; class=&quot;headerlink&quot; title=&quot;模块路径解析规则&quot;&gt;&lt;/a&gt;模块路径解析规则&lt;/
    
    </summary>
    
      <category term="编程语言" scheme="http:/dannyzhaoo.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="NodeJS" scheme="http:/dannyzhaoo.github.io/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Latex入门笔记</title>
    <link href="http:/dannyzhaoo.github.io/2017/06/06/Latex%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http:/dannyzhaoo.github.io/2017/06/06/Latex入门笔记/</id>
    <published>2017-06-06T12:20:23.000Z</published>
    <updated>2017-09-05T11:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为Latex的排版一直为人称道，而近期我们需要写一个指导手册，所以就学习用一下Latex。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>在ctex.org下载ctex套装(203Mb或1.3Gb)（含MikTeX及WinEdt），等着下载好了之后，就一步一步安装。</p>
<h2 id="写第一个文档"><a href="#写第一个文档" class="headerlink" title="写第一个文档"></a>写第一个文档</h2><p>主要是使用界面较为简单的<strong>TeXworks</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">\documentclass&#123;article&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">hello,world</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>此处的第一行 <code>\documentclass{article}</code> 中包含了一个控制序列（或称命令/标记）。所谓控制序列，是以反斜杠<code>\</code>开头，以第一个<strong>空格或非字母</strong> 的字符结束的一串文字，他们并不被输出，但是他们会影响输出文档的效果。这里的控制序列是 <code>documentclass</code>，它后面紧跟着的 <code>{article}</code> 代表这个控制序列有一个必要的参数，该参数的值为 <code>article</code>。这个控制序列的作用，是调用名为 “article” 的文档类。</p>
<p>尝试输出<strong>中文</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">\documentclass[UTF8]&#123;ctexart&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">你好，世界！</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>可以如愿输出中文，ps:用latex输出中文真是不容易！！！</p>
<p>相较于之前，这份代码有些细微的差别:</p>
<blockquote>
<ol>
<li>文档从<code>article</code>变为<code>ctextart</code>;</li>
<li>增加了文档累选项<code>UTF8</code>。</li>
</ol>
</blockquote>
<h2 id="作者、标题、日期"><a href="#作者、标题、日期" class="headerlink" title="作者、标题、日期"></a>作者、标题、日期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">\documentclass[UTF8]&#123;ctexart&#125;</div><div class="line">\title&#123;你好，world!&#125;</div><div class="line">\author&#123;Liam&#125;</div><div class="line">\date&#123;\today&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">\maketitle</div><div class="line">你好，world!</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>在 <code>document</code> 环境中，除了原本的<code>你好，world!</code>，还多了一个控制序列 <code>maketitle</code>。这个控制序列能将在导言区中定义的标题、作者、日期 按照预定的格式展现出来。</p>
<h2 id="章节和段落"><a href="#章节和段落" class="headerlink" title="章节和段落"></a>章节和段落</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">\documentclass[UTF8]&#123;ctexart&#125;</div><div class="line">\title&#123;你好，world!&#125;</div><div class="line">\author&#123;Liam&#125;</div><div class="line">\date&#123;\today&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">\maketitle</div><div class="line">\section&#123;你好中国&#125;</div><div class="line">中国在East Asia.</div><div class="line">\subsection&#123;Hello Beijing&#125;</div><div class="line">北京是capital of China.</div><div class="line">\subsubsection&#123;Hello Dongcheng District&#125;</div><div class="line">\paragraph&#123;Tian&apos;anmen Square&#125;</div><div class="line">is in the center of Beijing</div><div class="line">\subparagraph&#123;Chairman Mao&#125;</div><div class="line">is in the center of 天安门广场。</div><div class="line">\subsection&#123;Hello 山东&#125;</div><div class="line">\paragraph&#123;山东大学&#125; is one of the best university in 山东。</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>在文档类 <code>article</code>/<code>ctexart</code> 中，定义了五个控制序列来调整行文组织结构。他们分别是</p>
<ul>
<li><code>\section{·}</code></li>
<li><code>\subsection{·}</code></li>
<li><code>\subsubsection{·}</code></li>
<li><code>\paragraph{·}</code></li>
<li><code>\subparagraph{·}</code></li>
</ul>
<blockquote>
<p>在<code>report</code>/<code>ctexrep</code>中，还有<code>\chapter{·}</code>；在文档类<code>book</code>/<code>ctexbook</code>中，还定义了<code>\part{·}</code>。</p>
</blockquote>
<h2 id="插入目录"><a href="#插入目录" class="headerlink" title="插入目录"></a>插入目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">\documentclass[UTF8]&#123;ctexart&#125;</div><div class="line">\title&#123;你好，world!&#125;</div><div class="line">\author&#123;Liam&#125;</div><div class="line">\date&#123;\today&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">\maketitle</div><div class="line">\tableofcontents  %插入的位置</div><div class="line">\section&#123;你好中国&#125;</div><div class="line">中国在East Asia.</div><div class="line">\subsection&#123;Hello Beijing&#125;</div><div class="line">北京是capital of China.</div><div class="line">\subsubsection&#123;Hello Dongcheng District&#125;</div><div class="line">\paragraph&#123;Tian&apos;anmen Square&#125;</div><div class="line">is in the center of Beijing</div><div class="line">\subparagraph&#123;Chairman Mao&#125;</div><div class="line">is in the center of 天安门广场。</div><div class="line">\subsection&#123;Hello 山东&#125;</div><div class="line">\paragraph&#123;山东大学&#125; is one of the best university in 山东。</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>如果交换 <code>\maketitle</code> 和 <code>\tableofcontents</code> 的顺序，那么下面所有的内容全部就都变成了目录的内容了。而不是自动生成。</p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在 LaTeX 中插入图片，有很多种方式。最好用的应当属利用 <code>graphicx</code> 宏包提供的 <code>\includegraphics</code> 命令。比如你在你的 TeX 源文件同目录下，有名为 <code>a.jpg</code> 的图片，你可以用这样的方式将它插入到输出文档中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">\documentclass&#123;article&#125;</div><div class="line">\usepackage&#123;graphicx&#125;</div><div class="line">\begin&#123;document&#125;</div><div class="line">\includegraphics&#123;a.jpg&#125;</div><div class="line">\end&#123;document&#125;</div></pre></td></tr></table></figure>
<p>图片可能很大，超过了输出文件的纸张大小，或者干脆就是你自己觉得输出的效果不爽。这时候你可以用 <code>\includegraphics</code> 控制序列的可选参数来控制。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\includegraphics[width = .8\textwidth]&#123;a.jpg&#125;</div></pre></td></tr></table></figure>
<p>这样图片的宽度会被缩放至页面宽度的百分之八十，图片的总高度会按比例缩放。</p>
<blockquote>
<p><code>\includegraphics</code> 控制序列还有若干其他的可选参数可供使用，一般并用不到。感兴趣的话，可以去查看<a href="http://texdoc.net/texmf-dist/doc/latex/graphics/graphicx.pdf" target="_blank" rel="external">该宏包的文档</a>。</p>
</blockquote>
<p>插图和表格通常需要占据大块空间，所以在文字处理软件中我们经常需要调整他们的位置。<code>figure</code> 和 <code>table</code> 环境可以自动完成这样的任务；这种自动调整位置的环境称作浮动体(float)。我们以 <code>figure</code> 为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">\begin&#123;figure&#125;[htbp]</div><div class="line">\centering</div><div class="line">\includegraphics&#123;a.jpg&#125;</div><div class="line">\caption&#123;有图有真相&#125;</div><div class="line">\label&#123;fig:myphoto&#125;</div><div class="line">\end&#123;figure&#125;</div></pre></td></tr></table></figure>
<p>“htbp” 选项用来指定插图的理想位置，这几个字母分别代表here, top, bottom, float page，也就是就这里、页顶、页尾、浮动页(专门放浮动体的单独页面) 。<code>\centering</code> 用来使插图居中；<code>\caption</code> 命令设置插图标题，LaTeX 会自动给浮动体的标题加上编号。注意 <code>\label</code> 应该放在标题命令之后。</p>
<h2 id="版面设置"><a href="#版面设置" class="headerlink" title="版面设置"></a>版面设置</h2><h3 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h3><p>设置页边距，推荐使用 <code>geometry</code> 宏包。可以在<a href="http://texdoc.net/texmf-dist/doc/latex/geometry/geometry.pdf" target="_blank" rel="external">这里</a>查看它的说明文档。</p>
<p>比如我希望，将纸张的长度设置为 20cm、宽度设置为 15cm、左边距 1cm、右边距 2cm、上边距 3cm、下边距 4cm，可以在导言区加上这样几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">\usepackage&#123;geometry&#125;</div><div class="line">\geometry&#123;papersize=&#123;20cm,15cm&#125;&#125;</div><div class="line">\geometry&#123;left=1cm,right=2cm,top=3cm,bottom=4cm&#125;</div></pre></td></tr></table></figure>
<h3 id="页眉页脚"><a href="#页眉页脚" class="headerlink" title="页眉页脚"></a>页眉页脚</h3><p>设置页眉页脚，推荐使用 <code>fancyhdr</code> 宏包。可以在<a href="http://texdoc.net/texmf-dist/doc/latex/fancyhdr/fancyhdr.pdf" target="_blank" rel="external">这里</a>查看它的说明文档。</p>
<p>比如我希望，在页眉左边写上我的名字，中间写上今天的日期，右边写上我的电话；页脚的正中写上页码；页眉和正文之间有一道宽为 0.4pt 的横线分割，可以在导言区加上如下几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">\usepackage&#123;fancyhdr&#125;</div><div class="line">\pagestyle&#123;fancy&#125;</div><div class="line">\lhead&#123;\author&#125;</div><div class="line">\chead&#123;\date&#125;</div><div class="line">\rhead&#123;152xxxxxxxx&#125;</div><div class="line">\lfoot&#123;&#125;</div><div class="line">\cfoot&#123;\thepage&#125;</div><div class="line">\rfoot&#123;&#125;</div><div class="line">\renewcommand&#123;\headrulewidth&#125;&#123;0.4pt&#125;</div><div class="line">\renewcommand&#123;\headwidth&#125;&#123;\textwidth&#125;</div><div class="line">\renewcommand&#123;\footrulewidth&#125;&#123;0pt&#125;</div></pre></td></tr></table></figure>
<h3 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h3><p><code>CTeX</code> 宏集已经处理好了首行缩进的问题（自然段前空两格汉字宽度）。</p>
<blockquote>
<p>不使用 <code>CTeX</code> 宏集（使用 <code>xeCJK</code> 宏包）的话，请遵照以下提示操作。</p>
<p>中国人写文章，习惯每一段的段首都空出两个中文汉字的长度。美国人没有这个习惯，他们每一小节的段首都顶格。为了解决这个问题，我们可以在导言区调用 <code>\usepackage{indentfirst}</code>.</p>
<p>就算是这样，首行缩进的长度，仍然不符合中国人的习惯。我们可以在导言区添加这样的控制序列 <code>\setlength{\parindent}{\ccwd}</code> 来调整首行缩进的大小。这里的 <code>\ccwd</code> 是当前字号下一个中文汉字的宽度。</p>
</blockquote>
<h3 id="行间距"><a href="#行间距" class="headerlink" title="行间距"></a>行间距</h3><p>我们可以通过 <code>setspace</code>宏包提供的命令来调整行间距。比如在导言区添加如下内容，可以将行距设置为字号的 1.5 倍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\usepackage&#123;setspace&#125;</div><div class="line">\onehalfspacing</div></pre></td></tr></table></figure>
<p>具体可以查看该宏包的<a href="http://texdoc.net/texmf-dist/doc/latex/setspace/README" target="_blank" rel="external">文档</a>。</p>
<blockquote>
<p>请注意用词的差别：</p>
<ul>
<li>行距是字号的 1.5 倍；</li>
<li>1.5 倍行距。</li>
</ul>
<p>事实上，这不是设置 1.5 倍行距的正确方法，请参考：<a href="http://liam0205.me/2013/10/17/LaTeX-Linespace/" target="_blank" rel="external">http://liam0205.me/2013/10/17/LaTeX-Linespace/</a></p>
</blockquote>
<h3 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h3><p>我们可以通过修改长度 <code>\parskip</code> 的值来调整段间距。例如在导言区添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\addtolength&#123;\parskip&#125;&#123;.4em&#125;</div></pre></td></tr></table></figure>
<p>则可以在原有的基础上，增加段间距 0.4em。如果需要减小段间距，只需将该数值改为负值即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为Latex的排版一直为人称道，而近期我们需要写一个指导手册，所以就学习用一下Latex。&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;在ctex.or
    
    </summary>
    
      <category term="软技能" scheme="http:/dannyzhaoo.github.io/categories/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Latex" scheme="http:/dannyzhaoo.github.io/tags/Latex/"/>
    
  </entry>
  
</feed>
